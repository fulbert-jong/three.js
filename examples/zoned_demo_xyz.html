<!DOCTYPE html>
<html lang="en">
	<head>
		<title>zone demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="info">
		<!-- <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - XYZ loader<br/> -->
		<!-- asset from <a href="https://people.math.sc.edu/Burkardt/data/xyz/xyz.html" target="_blank" rel="noopener">people.math.sc.edu</a> via GNU LGPL -->
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { XYZLoader } from './jsm/loaders/XYZLoader.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';

			let camera, controls, scene, renderer, clock;

			let points;
			let frames=60;
			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				// camera.position.set( 10, 7, 10 );
				camera.position.z = 100;
				scene = new THREE.Scene();
				// scene.background = new THREE.Color( 0xcccccc );
				scene.add( camera );
				camera.lookAt( scene.position );

				clock = new THREE.Clock();

				const loader = new XYZLoader();
				loader.load( 'models/xyz/PCL_frame_' + frames + 'fixed_div_by_50_YZflip.xyz', function ( geometry ) {
					geometry.center();
					geometry.colors== 0x00ff00;
					geometry.colorsNeedUpdate=true;

					const vertexColors = ( geometry.hasAttribute( 'color' ) === true );

					const material = new THREE.PointsMaterial( { size: 0.1, vertexColors: false});

					points = new THREE.Points( geometry, material );
					scene.add( points );

				} );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

				// Controls
				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;
				// controls.enableZoom = true;

				// controls.screenSpacePanning = false;
				// controls.minDistance = 100;
				// controls.maxDistance = 500;
/* 				controls.minDistance = 100;
				controls.maxDistance = 500;

				controls.maxPolarAngle = Math.PI / 2; */

				// Lights
/* 				const dirLight1 = new THREE.DirectionalLight( 0xffffff );
				dirLight1.position.set( 1, 1, 1 );
				scene.add( dirLight1 );

				const dirLight2 = new THREE.DirectionalLight( 0x002288 );
				dirLight2.position.set( - 1, - 1, - 1 );
				scene.add( dirLight2 );

				const ambientLight = new THREE.AmbientLight( 0x222222 );
				scene.add( ambientLight ); */

				var keyLight = new THREE.DirectionalLight(new THREE.Color('hsl(30, 100%, 75%)'), 1.0);
				keyLight.position.set(-100, 0, 100);

				var fillLight = new THREE.DirectionalLight(new THREE.Color('hsl(240, 100%, 75%)'), 0.75);
				fillLight.position.set(100, 0, 100);

				var backLight = new THREE.DirectionalLight(0xffffff, 1.0);
				backLight.position.set(100, 0, -100).normalize();
				
				scene.add(keyLight);
				scene.add(fillLight);
				scene.add(backLight);

				document.addEventListener("keypress", function(pressed){

					if (pressed.key == "n"){
						frames+=1;
					} else if (pressed.key == "p"){
						frames-=1;
					} else if (pressed.key == "c"){
						points = scene.getObjectByName( 'models/xyz/PCL_frame_' + frames + 'fixed_div_by_50_YZflip.xyz');
						return;
					} else{
						return;
					}
					// Clean up and re-adding the light
					scene.remove.apply(scene, scene.children);
					scene.add(keyLight);
					scene.add(fillLight);
					scene.add(backLight);
					loader.load( 'models/xyz/PCL_frame_' + frames + 'fixed_div_by_50_YZflip.xyz', function ( geometry ) {

						geometry.center();

						const vertexColors = ( geometry.hasAttribute( 'color' ) === true );

						const material = new THREE.PointsMaterial( { size: 0.1, vertexColors: vertexColors } );

						points = new THREE.Points( geometry, material );
						scene.add( points );
						console.log(frames)
					} );
				});
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				const delta = clock.getDelta();

				renderer.render( scene, camera );

			}
	
		</script>

	</body>
</html>
